---
title: 玩蛇笔记之Python中的字符编码
date: 2016-12-17 12:46:57
categories:
- 开发
- Python
tags:
- Python
- 编码
---
{% cq %} 人生苦短,我玩Python {% endcq %}
{% fi /img/12.png, ..., Python %}
<!-- more -->
> 2017.3.21更新:URL编码和html转译序列相关
 
------

### Python3中的bytes类型和str类型
+ Python3的一个新特性是对字符串和二进制流数据进行了区分,文本都是Unicode,由str类型表示,二进制数据则由bytes类型表示.
+ Python3不允许以任何**隐式**的方式混用str和bytes类型,这意味着你不能拼接字符串和字节流,也不能在字节流里搜索字符串,也不能将字符串传入参数为字节流的函数,反之都亦然.
------
### 字符编码的那些事
> 在计算机历史的早期,美国为代表的英语系国家主导了整个计算机行业,26个英文字母组成了多样的英语单词,语句,文章.因此,最早的字符编码规范是ASCII码,一种8位即1个字节的编码规范,它可以涵盖整个英语系的编码需要.那么,编码是什么?编码是字符的二进制表示方法！我们都知道，所有的英文字符,标点符号,特殊字符,汉字,片假名等等最终存储在磁盘上都是01010101这类东西.在计算机内部，读取和存储数据归根结底，处理的都是0/1组成的比特流。可问题是,人类看不懂，看不懂，看不懂这些比特流！于是出现了字符编码,它是个翻译机,在计算机内部某个地方，透明的帮我们将比特流翻译成人类可以直接理解的文字.对于一般用户,不需要知道这个过程是什么原理，是怎么执行的.但是对于程序员却是个必须搞清楚的问题.

+ ASCII编码,,它规定1个字节8个比特位代表1个字符的编码,也就是“00000000”这么宽,一个一个字节的解读.例如:01000001表示大写字母A,有时我们会“偷懒"的用65这个十进制来表示A在ASCII中的编码.8个比特位,可以没有重复的表示2的8次方也就是255个字符.
+ 后来,计算机得到普及,中文,日文,韩文等等国家的文字需要在计算机内表示,ASCII的255位远远不够,于是标准组织制定出了叫做UNICODE的万国码,它规定任何一个字符(不管哪国的)至少以2个字节表示,可以更多.其中,英文字母就是用2个字节,而汉字是3个字节.这个编码虽然很好,满足了所有人的要求,但是它不兼容ASCII,同时还占用较多的空间和内存.因为,在计算机世界更多的字符是英文字母,明明可以1个字节就能够表示,非要用2个.
+ 于是UTF-8编码应运而生,它规定英文字母系列用1个字节表示,汉字用3个字节表示等等.因此,它兼容ASCII,可以解码早期的文档.UTF-8很快就得到了广泛的应用.
+ 我国也有自己创造的编码,像GBK,GB2312,BIG5,不想聊他们了,已经走远了.
------
### 回到bytes类型和str类型本身
+ 所以bytes类型就是10100011这种比特流,我们无论是写还是读都不可能直接和这种东西打交道,它必须要有一个编码规则来使它变得有意义,用不同的编码规则解读它就会有不同的含义.

        >>> s = "中文"
        >>> s
        '中文'
        >>> type(s)
        <class 'str'>
        >>> b = bytes(s,encoding='utf-8')
        >>> b
        b'\xe4\xb8\xad\xe6\x96\x87'
        >>> type(b)
        <class 'bytes'>

+ s是个字符串类型.Python有个内置函数bytes()可以将字符串转换成bytes类型,b实际上是一串01的组合,但为了在ide环境中让我们相对直观的观察,它被表现成了b'\xe4\xb8\xad\xe6\x96\x87'这种形式,开头的b表示这是一个bytes类型.\xe4是十六进制的表示方式,它占用1个字节的长度,因此”中文“被编码成utf-8后,我们可以数得出一共用了6个字节,每个汉字占用3个,这印证了上面的论述.在使用内置函数bytes()的时候,必须明确encoding的参数,不可省略.
+ 字符串类（str）里有一个encode()方法,它是从字符串向比特流的编码过程.而bytes类型恰好有个decode()方法,它是从比特流向字符串解码的过程.除此之外,我们查看Python源码会发现bytes和str拥有几乎一模一样的方法列表,最大的区别就是encode和decode.
+ 所以从本质上来讲,字符串在磁盘上的保存形式也是01的组合,也需要编码解码

    1. **在将字符串存入磁盘和从磁盘读取字符串的过程中,Python自动地帮你完成了编码和解码的工作,你不需要关心它的过程**.
    2. **使用bytes类型,实质上是告诉Python,不需要它帮你自动地完成编码和解码的工作,而是用户自己手动进行,并指定编码格式**.
    3. **Python已经严格区分了bytes和str两种数据类型,你不能在需要bytes类型参数的时候使用str参数,反之亦然.这点在读写磁盘文件时容易碰到**.

+ 在bytes和str的互相转换过程中,实际就是编码解码的过程,必须显式地指定编码格式.

        >>> b
        b'\xe4\xb8\xad\xe6\x96\x87'
        >>> type(b)
        <class 'bytes'>
        >>> s1 = str(b)
        >>> s1
        "b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'"
        >>> type(s1)
        <class 'str'>
        >>> s1 = str(b,encoding='utf-8')
        >>> s1
        '中文'
        >>> type(s1)
        <class 'str'>

------

### URL编码以及html转译序列相关
+ 最近在玩python爬虫和渗透测试的时候会遇到很多url编码和html转译序列相关的问题,我觉得如果对编码,url编码,html转译序列理解不清楚的话会将这几个东西弄得非常混乱,有必要梳理一下
+ 其实很简单,首先通过上面的笔记就可以了解utf-8等编码,url编码存在的原因是在url中有一些特殊字符时候特殊含义的不能直接以本意传输包括中文等等,所以就需要进行url编码,url编码会将这些特殊字符换成以`%`开头后连两位十六进制组成,如果是中文会先进行utf-8或者别的编码然后将编码后的十六进制每两位加`%`变成url编码例如`周易`经过url编码后就会变成`%E5%91%A8%E6%98%93`
+ 最后要提一下html转译序列,这个玩意说白了和编码没有关系,存在的原因是html中有很多特殊字符有特殊含义,为了不让浏览器误把内容当成需要解析的内容而将这些特殊字符转译成以`&`开头的东西,中文也一样不过以`&#`开头后接当前页面编码,这里分两种情况`&#x`后面会接十六进制,`&#`后面接十进制.还有一种直接指定编码列如`\u`开头的就是unicode编码不受页面编码影响.
