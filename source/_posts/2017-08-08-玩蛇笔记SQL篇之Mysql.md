---
title: 玩蛇笔记SQL篇之Mysql
date: 2017-08-08 20:31:44
categories:
- 开发
- Python
- SQL
tags:
- Mysql

---
{% cq %} 人生苦短,我玩Python {% endcq %}
{% fi /img/12.png, ..., Python %}
<!-- more -->
> SQL基本和Mysql的使用

------

### Mysql
这个没什么好说的.安装,注意root用户的密码配置就可以了
启动Mysql的后台服务.
{% codeblock %}
mysqld
{% endcodeblock %}
使用命令链接mysql服务
{% codeblock %}
mysql -u root -p
{% endcodeblock %}
根据不同的操作系统平台,有不同的安装方式和过程..没什么好说的.无非就是添加环境变量什么的.

------

### 数据库的操作

1. 显示数据库
    {% codeblock %}
    SHOW DATABASES;
    {% endcodeblock %}
    Mysql默认数据库:
    + mysql-用户权限相关数据
    + test-用于用户测试数据
    + information_schema-Mysql本身架构相关数据

2. 创建数据库
    {% codeblock %}
    # utf-8
    CREATE DATABASE 数据库名称 DEFAULT CHARSET utf8 COLLATE utf8_general_ci;
    # gbk
    CREATE DATABASE 数据库名称 DEFAULT CHARACTER SET gbk COLLATE gbk_chinese_ci;
    {% endcodeblock %}

3. 使用数据库以及显示数据库中的表
    {% codeblock %}
    USE db_name;
    SHOW TABLES;
    {% endcodeblock %}

4. 授权管理
    {% codeblock 基本命令 %}
    show grants for '用户'@'IP地址'                  -- 查看权限
    grant  权限 on 数据库.表 to   '用户'@'IP地址'      -- 授权
    revoke 权限 on 数据库.表 from '用户'@'IP地址'      -- 取消权限
    {% endcodeblock %}
    {% codeblock 权限相关 %}
    all privileges  除grant外的所有权限
    select          仅查权限
    select,insert   查和插入权限
    ...
    usage                   无访问权限
    alter                   使用alter table
    alter routine           使用alter procedure和drop procedure
    create                  使用create table
    create routine          使用create procedure
    create temporary tables 使用create temporary tables
    create user             使用create user、drop user、rename user和revoke  all privileges
    create view             使用create view
    delete                  使用delete
    drop                    使用drop table
    execute                 使用call和存储过程
    file                    使用select into outfile 和 load data infile
    grant option            使用grant 和 revoke
    index                   使用index
    insert                  使用insert
    lock tables             使用lock table
    process                 使用show full processlist
    select                  使用select
    show databases          使用show databases
    show view               使用show view
    update                  使用update
    reload                  使用flush
    shutdown                使用mysqladmin shutdown(关闭MySQL)
    super                   􏱂􏰈使用change master、kill、logs、purge、master和set global。还允许mysqladmin􏵗􏵘􏲊􏲋调试登陆
    replication client      服务器位置的访问
    replication slave       由复制从属使用    
    {% endcodeblock %}

    {% codeblock 数据库相关 %}
    对于目标数据库以及内部其他：
    数据库名.*           数据库中的所有
    数据库名.表          指定数据库中的某张表
    数据库名.存储过程     指定数据库中的存储过程
    *.*                所有数据库
    {% endcodeblock %}

    {% codeblock 用户和IP相关 %}
    用户名@IP地址         用户只能在改IP下才能访问
    用户名@192.168.1.%   用户只能在改IP段下才能访问(通配符%表示任意)
    用户名@%             用户可以再任意IP下访问(默认IP地址为%)
    {% endcodeblock %}

    {% codeblock 实例 %}
    grant all privileges on db1.tb1 TO '用户名'@'IP'

    grant select on db1.* TO '用户名'@'IP'

    grant select,insert on *.* TO '用户名'@'IP'

    revoke select on db1.tb1 from '用户名'@'IP'
    {% endcodeblock %}

    {% codeblock 特殊 %}
    flush privileges，将数据读取到内存中，从而立即生效。
    {% endcodeblock %}

    {% codeblock 忘记密码 %}
    # 启动免授权服务端
    mysqld --skip-grant-tables

    # 客户端
    mysql -u root -p

    # 修改用户名密码
    update mysql.user set authentication_string=password('666') where user='root';
    flush privileges;
    {% endcodeblock %}

------

### 表的基本操作
1. 创建表
    {% codeblock 创建表 %}
    create table 表名(
        列名  类型  是否可以为空，
        列名  类型  是否可以为空
    )ENGINE=InnoDB DEFAULT CHARSET=utf8
    {% endcodeblock %}

    {% codeblock 是否可以为空 %}
    是否可空，null表示空，非字符串
    not null    - 不可空
    null        - 可空
    {% endcodeblock %}

    {% codeblock 默认值 %}
    默认值，创建列时可以指定默认值，当插入数据时如果未主动设置，则自动添加默认值
    create table tb1(
        nid int not null defalut 2,
        num int not null
    )
    {% endcodeblock %}

    {% codeblock 自增 %}
   自增，如果为某列设置自增列，插入数据时无需设置此列，默认将自增（表中只能有一个自增列）
    create table tb1(
        nid int not null auto_increment primary key,
        num int null
    )
    或
    create table tb1(
        nid int not null auto_increment,
        num int null,
        index(nid)
    )
    注意：1、对于自增列，必须是索引（含主键）。
         2、对于自增可以设置步长和起始值
             show session variables like 'auto_inc%';
             set session auto_increment_increment=2;
             set session auto_increment_offset=10;

             shwo global  variables like 'auto_inc%';
             set global auto_increment_increment=2;
             set global auto_increment_offset=10;
    {% endcodeblock %}

    {% codeblock 主键 %}
    主键，一种特殊的唯一索引，不允许有空值，如果主键使用单个列，则它的值必须唯一，如果是多列，则其组合必须唯一。
    create table tb1(
        nid int not null auto_increment primary key,
        num int null
    )
    或
    create table tb1(
        nid int not null,
        num int not null,
        primary key(nid,num)
    )
    {% endcodeblock %}

    {% codeblock 外键 %}
    外键，一个特殊的索引，只能是指定内容
    creat table color(
        nid int not null primary key,
        name char(16) not null
    )

    create table fruit(
        nid int not null primary key,
        smt char(32) null ,
        color_id int not null,
        constraint fk_cc foreign key (color_id) references color(nid)
    )
    {% endcodeblock %}

2. 删除表
    {% codeblock %}
    drop table 表名
    {% endcodeblock %}

3. 清空表
    {% codeblock %}
    delete from 表名
    truncate table 表名
    {% endcodeblock %}

4. 修改表
    {% codeblock %}
    添加列：alter table 表名 add 列名 类型
    删除列：alter table 表名 drop column 列名
    修改列：
            alter table 表名 modify column 列名 类型;  -- 类型
            alter table 表名 change 原列名 新列名 类型; -- 列名，类型
      
    添加主键：
            alter table 表名 add primary key(列名);
    删除主键：
            alter table 表名 drop primary key;
            alter table 表名  modify  列名 int, drop primary key;
      
    添加外键：alter table 从表 add constraint 外键名称（形如：FK_从表_主表） foreign key 从表(外键字段) references 主表(主键字段);
    删除外键：alter table 表名 drop foreign key 外键名称
      
    修改默认值：ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000;
    删除默认值：ALTER TABLE testalter_tbl ALTER i DROP DEFAULT;
    {% endcodeblock %}

5. 基本数据类型
    {% codeblock %}
    {% raw %}
            bit[(M)]
            二进制位（101001），m表示二进制位的长度（1-64），默认m＝1

            tinyint[(m)] [unsigned] [zerofill]

                小整数，数据类型用于保存一些范围的整数数值范围：
                有符号：
                    -128 ～ 127.
                无符号：
                    0 ～ 255

                特别的： MySQL中无布尔值，使用tinyint(1)构造。

            int[(m)][unsigned][zerofill]

                整数，数据类型用于保存一些范围的整数数值范围：
                    有符号：
                        -2147483648 ～ 2147483647
                    无符号：
                        0 ～ 4294967295

                特别的：整数类型中的m仅用于显示，对存储范围无限制。例如： int(5),当插入数据2时，select 时数据显示为： 00002

            bigint[(m)][unsigned][zerofill]
                大整数，数据类型用于保存一些范围的整数数值范围：
                    有符号：
                        -9223372036854775808 ～ 9223372036854775807
                    无符号：
                        0  ～  18446744073709551615

            decimal[(m[,d])] [unsigned] [zerofill]
                准确的小数值，m是数字总个数（负号不算），d是小数点后个数。 m最大值为65，d最大值为30。

                特别的：对于精确数值计算时需要用此类型
                       decaimal能够存储精确值的原因在于其内部按照字符串存储。

            FLOAT[(M,D)] [UNSIGNED] [ZEROFILL]
                单精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。
                    无符号：
                        -3.402823466E+38 to -1.175494351E-38,
                        0
                        1.175494351E-38 to 3.402823466E+38
                    有符号：
                        0
                        1.175494351E-38 to 3.402823466E+38

                 --- 数值越大，越不准确 ---

            DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL]
                双精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。

                    无符号：
                        -1.7976931348623157E+308 to -2.2250738585072014E-308
                        0
                        2.2250738585072014E-308 to 1.7976931348623157E+308
                    有符号：
                        0
                        2.2250738585072014E-308 to 1.7976931348623157E+308
                --- 数值越大，越不准确 ---


            char (m)
                char数据类型用于表示固定长度的字符串，可以包含最多达255个字符。其中m代表字符串的长度。
                PS: 即使数据小于m长度，也会占用m长度
            varchar(m)
                varchars数据类型用于变长的字符串，可以包含最多达255个字符。其中m代表该数据类型所允许保存的字符串的最大长度，只要长度小于该最大值的字符串都可以被保存在该数据类型中。

                注：虽然varchar使用起来较为灵活，但是从整个系统的性能角度来说，char数据类型的处理速度更快，有时甚至可以超出varchar处理速度的50%。因此，用户在设计数据库时应当综合考虑各方面的因素，以求达到最佳的平衡

            text
                text数据类型用于保存变长的大字符串，可以组多到65535 (2**16 − 1)个字符。

            mediumtext
                A TEXT column with a maximum length of 16,777,215 (2**24 − 1) characters.

            longtext
                A TEXT column with a maximum length of 4,294,967,295 or 4GB (2**32 − 1) characters.


            enum
                枚举类型，
                An ENUM column can have a maximum of 65,535 distinct elements. (The practical limit is less than 3000.)
                示例：
                    CREATE TABLE shirts (
                        name VARCHAR(40),
                        size ENUM('x-small', 'small', 'medium', 'large', 'x-large')
                    );
                    INSERT INTO shirts (name, size) VALUES ('dress shirt','large'), ('t-shirt','medium'),('polo shirt','small');

            set
                集合类型
                A SET column can have a maximum of 64 distinct members.
                示例：
                    CREATE TABLE myset (col SET('a', 'b', 'c', 'd'));
                    INSERT INTO myset (col) VALUES ('a,d'), ('d,a'), ('a,d,a'), ('a,d,d'), ('d,a,d');

            DATE
                YYYY-MM-DD（1000-01-01/9999-12-31）

            TIME
                HH:MM:SS（'-838:59:59'/'838:59:59'）

            YEAR
                YYYY（1901/2155）

            DATETIME

                YYYY-MM-DD HH:MM:SS（1000-01-01 00:00:00/9999-12-31 23:59:59    Y）

            TIMESTAMP

                YYYYMMDD HHMMSS（1970-01-01 00:00:00/2037 年某时）
    {% endraw %}
    {% endcodeblock %}
    此外还有二进制数据：TinyBlob、Blob、MediumBlob、LongBlob 用于存储图片,音乐什么的.

------

### 对表数据的操作
1. 增加
    {% codeblock %}
    insert into 表 (列名,列名...) values (值,值,值...)
    insert into 表 (列名,列名...) values (值,值,值...),(值,值,值...)
    insert into 表 (列名,列名...) select (列名,列名...) from 表
    {% endcodeblock %}
2. 删除
    {% codeblock %}
    delete from 表
    delete from 表 where id＝1 and name＝'alex'
    {% endcodeblock %}
3. 修改
    {% codeblock %}
    update 表 set name ＝ 'alex' where id>1
    {% endcodeblock %}
4. 查找
    {% codeblock %}
    select * from 表
    select * from 表 where id > 1
    select nid,name,gender as gg from 表 where id > 1
    {% endcodeblock %}
5. 其他
    {% codeblock %}
    {% raw %}
    a、条件
        select * from 表 where id > 1 and name != 'alex' and num = 12;
     
        select * from 表 where id between 5 and 16;
     
        select * from 表 where id in (11,22,33)
        select * from 表 where id not in (11,22,33)
        select * from 表 where id in (select nid from 表)
     
    b、通配符
        select * from 表 where name like 'ale%'  - ale开头的所有（多个字符串）
        select * from 表 where name like 'ale_'  - ale开头的所有（一个字符）
     
    c、限制
        select * from 表 limit 5;            - 前5行
        select * from 表 limit 4,5;          - 从第4行开始的5行
        select * from 表 limit 5 offset 4    - 从第4行开始的5行
     
    d、排序
        select * from 表 order by 列 asc              - 根据 “列” 从小到大排列
        select * from 表 order by 列 desc             - 根据 “列” 从大到小排列
        select * from 表 order by 列1 desc,列2 asc    - 根据 “列1” 从大到小排列，如果相同则按列2从小到大排序
     
    e、分组
        select num from 表 group by num
        select num,nid from 表 group by num,nid
        select num,nid from 表  where nid > 10 group by num,nid order nid desc
        select num,nid,count(*),sum(score),max(score),min(score) from 表 group by num,nid
     
        select num from 表 group by num having max(id) > 10
     
        特别的：group by 必须在where之后，order by之前
     
    f、连表
        无对应关系则不显示
        select A.num, A.name, B.name
        from A,B
        Where A.nid = B.nid
     
        无对应关系则不显示
        select A.num, A.name, B.name
        from A inner join B
        on A.nid = B.nid
     
        A表所有显示，如果B中无对应关系，则值为null
        select A.num, A.name, B.name
        from A left join B
        on A.nid = B.nid
     
        B表所有显示，如果B中无对应关系，则值为null
        select A.num, A.name, B.name
        from A right join B
        on A.nid = B.nid
     
    g、组合
        组合，自动处理重合
        select nickname
        from A
        union
        select name
        from B
     
        组合，不处理重合
        select nickname
        from A
        union all
        select name
        from B
    {% endraw %}
    {% endcodeblock %}

------

### Mysql的进阶

#### 视图
视图是一个虚拟表（非真实存在）,其本质是**根据SQL语句获取动态的数据集**，并为其命名，用户使用时只需使用名称即可获取结果集，并可以将其当作表来使用。
{% codeblock %}
{% raw %}
SELECT
    *
FROM
    (
        SELECT
            nid,
            NAME
        FROM
            tb1
        WHERE
            nid > 2
    ) AS A
WHERE
    A. NAME > 'alex';
{% endraw %}
{% endcodeblock %}

1. 创建视图
    {% codeblock %}
    {% raw %}
    --格式：CREATE VIEW 视图名称 AS  SQL语句
    CREATE VIEW v1 AS 
    SELET nid, 
        name
    FROM
        A
    WHERE
        nid > 4
    {% endraw %}
    {% endcodeblock %}
2. 删除视图
    {% codeblock %}
    --格式：DROP VIEW 视图名称

    DROP VIEW v1
    {% endcodeblock %}
3. 修改视图
    {% codeblock %}
    {% raw %}
    -- 格式：ALTER VIEW 视图名称 AS SQL语句

    ALTER VIEW v1 AS
    SELET A.nid,
        B. NAME
    FROM
        A
    LEFT JOIN B ON A.id = B.nid
    LEFT JOIN C ON A.id = C.nid
    WHERE
        A.id > 2
    AND C.nid < 5
    {% endraw %}
    {% endcodeblock %}
4. 使用视图
    {% codeblock %}
    select * from v1
    {% endcodeblock %}

#### 触发器
对某个表进行 增/删/改 操作的前后如果希望触发某个特定的行为时,可以使用触发器,触发器用于定制用户对表的行进行 增/删/改 前后的行为.

1. 创建触发器
    {% codeblock %}
    {% raw %}
    # 插入前
    CREATE TRIGGER tri_before_insert_tb1 BEFORE INSERT ON tb1 FOR EACH ROW
    BEGIN
        ...
    END

    # 插入后
    CREATE TRIGGER tri_after_insert_tb1 AFTER INSERT ON tb1 FOR EACH ROW
    BEGIN
        ...
    END

    # 删除前
    CREATE TRIGGER tri_before_delete_tb1 BEFORE DELETE ON tb1 FOR EACH ROW
    BEGIN
        ...
    END

    # 删除后
    CREATE TRIGGER tri_after_delete_tb1 AFTER DELETE ON tb1 FOR EACH ROW
    BEGIN
        ...
    END

    # 更新前
    CREATE TRIGGER tri_before_update_tb1 BEFORE UPDATE ON tb1 FOR EACH ROW
    BEGIN
        ...
    END

    # 更新后
    CREATE TRIGGER tri_after_update_tb1 AFTER UPDATE ON tb1 FOR EACH ROW
    BEGIN
        ...
    END
    {% endraw %}
    {% endcodeblock %}

    {% codeblock 插入前触发器实例 %}
    delimiter //
    CREATE TRIGGER tri_before_insert_tb1 BEFORE INSERT ON tb1 FOR EACH ROW
    BEGIN

    IF NEW. NAME == 'alex' THEN
        INSERT INTO tb2 (NAME)
    VALUES
        ('aa')
    END
    END//
    delimiter ;
    {% endcodeblock %}

    {% codeblock 插入后触发器实例  %}
    {% raw %}
    delimiter //
    CREATE TRIGGER tri_after_insert_tb1 AFTER INSERT ON tb1 FOR EACH ROW
    BEGIN
        IF NEW. num = 666 THEN
            INSERT INTO tb2 (NAME)
            VALUES
                ('666'),
                ('666') ;
        ELSEIF NEW. num = 555 THEN
            INSERT INTO tb2 (NAME)
            VALUES
                ('555'),
                ('555') ;
        END IF;
    END//
    delimiter ;
    {% endraw %}
    {% endcodeblock %}
    NEW表示即将插入的数据行,OLD表示即将删除的数据行.
2. 删除触发器
    {% codeblock %}
    DROP TRIGGER tri_after_insert_tb1;
    {% endcodeblock %}
3. 使用触发器
    触发器无法由用户直接调用,而知由于对表的增/删/改操作被动引发的。

#### 存储过程
存储过程是一个SQL语句集合,当主动去调用存储过程时,其中内部的SQL语句会按照逻辑执行.

1.  创建存储过程
    {% codeblock %}
    {% raw %}
    -- 创建存储过程

    delimiter //
    create procedure p1()
    BEGIN
        select * from t1;
    END//
    delimiter ;



    -- 执行存储过程

    call p1()
    {% endraw %}
    {% endcodeblock %}

    对于存储过程，可以接收参数，其参数有三类: in仅用于传入参数用,out仅用于返回值用,inout既可以传入又可以当作返回值

    {% codeblock %}
    {% raw %}
    -- 创建存储过程
    delimiter \\
    create procedure p1(
        in i1 int,
        in i2 int,
        inout i3 int,
        out r1 int
    )
    BEGIN
        DECLARE temp1 int;
        DECLARE temp2 int default 0;
        
        set temp1 = 1;

        set r1 = i1 + i2 + temp1 + temp2;
        
        set i3 = i3 + 100;

    end\\
    delimiter ;

    -- 执行存储过程
    set @t1 =4;
    set @t2 = 0;
    CALL p1 (1, 2 ,@t1, @t2);
    SELECT @t1,@t2;
    {% endraw %}
    {% endcodeblock %}

    {% codeblock 结果集 %}
    delimiter //
    create procedure p1()
    begin
        select * from v1;
    end //
    delimiter ;
    {% endcodeblock %}

    {% codeblock 结果集和out值 %}
    {% raw %}
    delimiter //
    create procedure p2(
        in n1 int,
        inout n3 int,
        out n2 int,
    )
    begin
        declare temp1 int ;
        declare temp2 int default 0;

        select * from v1;
        set n2 = n1 + 100;
        set n3 = n3 + n1 + 100;
    end //
    delimiter ;
    {% endraw %}
    {% endcodeblock %}

    {% codeblock 事务 %}
    {% raw %}
    delimiter \\
        create PROCEDURE p1(
            OUT p_return_code tinyint
        )
        BEGIN 
          DECLARE exit handler for sqlexception 
          BEGIN 
            -- ERROR 
            set p_return_code = 1; 
            rollback; 
          END; 
         
          DECLARE exit handler for sqlwarning 
          BEGIN 
            -- WARNING 
            set p_return_code = 2; 
            rollback; 
          END; 
         
          START TRANSACTION; 
            DELETE from tb1;
            insert into tb2(name)values('seven');
          COMMIT; 
         
          -- SUCCESS 
          set p_return_code = 0; 
         
          END\\
    delimiter ;
    {% endraw %}
    {% endcodeblock %}

    {% codeblock 游标 %}
    {% raw %}
    delimiter //
    create procedure p3()
    begin 
        declare ssid int; -- 自定义变量1  
        declare ssname varchar(50); -- 自定义变量2  
        DECLARE done INT DEFAULT FALSE;


        DECLARE my_cursor CURSOR FOR select sid,sname from student;
        DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
        
        open my_cursor;
            xxoo: LOOP
                fetch my_cursor into ssid,ssname;
                if done then 
                    leave xxoo;
                END IF;
                insert into teacher(tname) values(ssname);
            end loop xxoo;
        close my_cursor;
    end  //
    delimter ;
    {% endraw %}
    {% endcodeblock %}

    {% codeblock 动态执行sql %}
    {% raw %}
    delimiter \\
    CREATE PROCEDURE p4 (
        in nid int
    )
    BEGIN
        PREPARE prod FROM 'select * from student where sid > ?';
        EXECUTE prod USING @nid;
        DEALLOCATE prepare prod; 
    END\\
    delimiter ;
    {% endraw %}
    {% endcodeblock %}

2. 删除存储过程
    {% codeblock %}
    drop procedure proc_name;
    {% endcodeblock %}

3. 执行存储过程
    {% codeblock %}
    {% raw %}
    -- 无参数
    call proc_name()

    -- 有参数，全in
    call proc_name(1,2)

    -- 有参数，有in，out，inout
    set @t1=0;
    set @t2=3;
    call proc_name(1,2,@t1,@t2)
    {% endraw %}
    {% endcodeblock %}

4. pymysql操作存储过程
    {% codeblock %}
    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import pymysql

    conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='123', db='t1')
    cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)
    # 执行存储过程
    cursor.callproc('p1', args=(1, 22, 3, 4))
    # 获取执行完存储的参数
    cursor.execute("select @_p1_0,@_p1_1,@_p1_2,@_p1_3")
    result = cursor.fetchall()

    conn.commit()
    cursor.close()
    conn.close()


    print(result)
    {% endcodeblock %}

#### 函数
mysql内置了很多函数,类似Python的内置函数
{% codeblock %}
{% raw %}
CHAR_LENGTH(str)
    返回值为字符串str 的长度，长度的单位为字符。一个多字节字符算作一个单字符。
    对于一个包含五个二字节字符集, LENGTH()返回值为 10, 而CHAR_LENGTH()的返回值为5。

CONCAT(str1,str2,...)
    字符串拼接
    如有任何一个参数为NULL ，则返回值为 NULL。
CONCAT_WS(separator,str1,str2,...)
    字符串拼接（自定义连接符）
    CONCAT_WS()不会忽略任何空字符串。 (然而会忽略所有的 NULL）。

CONV(N,from_base,to_base)
    进制转换
    例如：
        SELECT CONV('a',16,2); 表示将 a 由16进制转换为2进制字符串表示

FORMAT(X,D)
    将数字X 的格式写为'#,###,###.##',以四舍五入的方式保留小数点后 D 位， 并将结果以字符串的形式返回。若  D 为 0, 则返回结果不带有小数点，或不含小数部分。
    例如：
        SELECT FORMAT(12332.1,4); 结果为： '12,332.1000'
INSERT(str,pos,len,newstr)
    在str的指定位置插入字符串
        pos：要替换位置其实位置
        len：替换的长度
        newstr：新字符串
    特别的：
        如果pos超过原字符串长度，则返回原字符串
        如果len超过原字符串长度，则由新字符串完全替换
INSTR(str,substr)
    返回字符串 str 中子字符串的第一个出现位置。

LEFT(str,len)
    返回字符串str 从开始的len位置的子序列字符。

LOWER(str)
    变小写

UPPER(str)
    变大写

LTRIM(str)
    返回字符串 str ，其引导空格字符被删除。
RTRIM(str)
    返回字符串 str ，结尾空格字符被删去。
SUBSTRING(str,pos,len)
    获取字符串子序列

LOCATE(substr,str,pos)
    获取子序列索引位置

REPEAT(str,count)
    返回一个由重复的字符串str 组成的字符串，字符串str的数目等于count 。
    若 count <= 0,则返回一个空字符串。
    若str 或 count 为 NULL，则返回 NULL 。
REPLACE(str,from_str,to_str)
    返回字符串str 以及所有被字符串to_str替代的字符串from_str 。
REVERSE(str)
    返回字符串 str ，顺序和字符顺序相反。
RIGHT(str,len)
    从字符串str 开始，返回从后边开始len个字符组成的子序列

SPACE(N)
    返回一个由N空格组成的字符串。

SUBSTRING(str,pos) , SUBSTRING(str FROM pos) SUBSTRING(str,pos,len) , SUBSTRING(str FROM pos FOR len)
    不带有len 参数的格式从字符串str返回一个子字符串，起始于位置 pos。带有len参数的格式从字符串str返回一个长度同len字符相同的子字符串，起始于位置 pos。 使用 FROM的格式为标准 SQL 语法。也可能对pos使用一个负值。假若这样，则子字符串的位置起始于字符串结尾的pos 字符，而不是字符串的开头位置。在以下格式的函数中可以对pos 使用一个负值。

    mysql> SELECT SUBSTRING('Quadratically',5);
        -> 'ratically'

    mysql> SELECT SUBSTRING('foobarbar' FROM 4);
        -> 'barbar'

    mysql> SELECT SUBSTRING('Quadratically',5,6);
        -> 'ratica'

    mysql> SELECT SUBSTRING('Sakila', -3);
        -> 'ila'

    mysql> SELECT SUBSTRING('Sakila', -5, 3);
        -> 'aki'

    mysql> SELECT SUBSTRING('Sakila' FROM -4 FOR 2);
        -> 'ki'

TRIM([{BOTH | LEADING | TRAILING} [remstr] FROM] str) TRIM(remstr FROM] str)
    返回字符串 str ， 其中所有remstr 前缀和/或后缀都已被删除。若分类符BOTH、LEADIN或TRAILING中没有一个是给定的,则假设为BOTH 。 remstr 为可选项，在未指定情况下，可删除空格。

    mysql> SELECT TRIM('  bar   ');
            -> 'bar'

    mysql> SELECT TRIM(LEADING 'x' FROM 'xxxbarxxx');
            -> 'barxxx'

    mysql> SELECT TRIM(BOTH 'x' FROM 'xxxbarxxx');
            -> 'bar'

    mysql> SELECT TRIM(TRAILING 'xyz' FROM 'barxxyz');
            -> 'barx'
{% endraw %}
{% endcodeblock %}

1. 自定义函数
    {% codeblock %}
    delimiter \\
    create function f1(
        i1 int,
        i2 int)
    returns int
    BEGIN
        declare num int;
        set num = i1 + i2;
        return(num);
    END \\
    delimiter ;
    {% endcodeblock %}

2. 删除函数
    {% codeblock %}
    drop function func_name;
    {% endcodeblock %}

3. 执行函数
    {% codeblock %}
    # 获取返回值
    declare @i VARCHAR(32);
    select UPPER('alex') into @i;
    SELECT @i;


    # 在查询中使用
    select f1(11,nid) ,name from tb2;
    {% endcodeblock %}

#### 事务
事务用于将某些操作的多个SQL作为原子性操作,一旦有某一个出现错误,即可回滚到原来的状态,从而保证数据库数据完整性.
{% codeblock %}
{% raw %}
delimiter \\
create PROCEDURE p1(
    OUT p_return_code tinyint
)
BEGIN 
  DECLARE exit handler for sqlexception 
  BEGIN 
    -- ERROR 
    set p_return_code = 1; 
    rollback; 
  END; 
 
  DECLARE exit handler for sqlwarning 
  BEGIN 
    -- WARNING 
    set p_return_code = 2; 
    rollback; 
  END; 
 
  START TRANSACTION; 
    DELETE from tb1;
    insert into tb2(name)values('seven');
  COMMIT; 
 
  -- SUCCESS 
  set p_return_code = 0; 
 
  END\\
delimiter ;


set @i =0;
call p1(@i);
select @i;
{% endraw %}
{% endcodeblock %}

#### 索引


#### 其他
1. 条件语句
    {% codeblock %}
    {% raw %}
    delimiter \\
    CREATE PROCEDURE proc_if ()
    BEGIN
        
        declare i int default 0;
        if i = 1 THEN
            SELECT 1;
        ELSEIF i = 2 THEN
            SELECT 2;
        ELSE
            SELECT 7;
        END IF;

    END\\
    delimiter ;
    {% endraw %}
    {% endcodeblock %}
2. 循环语句
    {% codeblock while循环%}
    {% raw %}
    delimiter \\
    CREATE PROCEDURE proc_while ()
    BEGIN

        DECLARE num INT ;
        SET num = 0 ;
        WHILE num < 10 DO
            SELECT
                num ;
            SET num = num + 1 ;
        END WHILE ;

    END\\
    delimiter ;
    {% endraw %}
    {% endcodeblock %}

    {% codeblock repeat %}
    {% raw %}
    delimiter \\
    CREATE PROCEDURE proc_repeat ()
    BEGIN

        DECLARE i INT ;
        SET i = 0 ;
        repeat
            select i;
            set i = i + 1;
            until i >= 5
        end repeat;

    END\\
    delimiter ;
    {% endraw %}
    {% endcodeblock %}

    {% codeblock %}
    BEGIN
        
        declare i int default 0;
        loop_label: loop
            
            set i=i+1;
            if i<8 then
                iterate loop_label;
            end if;
            if i>=10 then
                leave loop_label;
            end if;
            select i;
        end loop loop_label;

    END
    {% endcodeblock %}
3. 动态执行sql语句
    {% codeblock %}
    {% raw %}
    delimiter \\
    DROP PROCEDURE IF EXISTS proc_sql \\
    CREATE PROCEDURE proc_sql ()
    BEGIN
        declare p1 int;
        set p1 = 11;
        set @p1 = p1;

        PREPARE prod FROM 'select * from tb2 where nid > ?';
        EXECUTE prod USING @p1;
        DEALLOCATE prepare prod; 

    END\\
    delimiter ;
    {% endraw %}
    {% endcodeblock %}

#### 索引
索引,是数据库中专门用于帮助用户快速查询数据的一种数据结构.类似于字典中的目录,查找字典内容时可以根据目录查找到数据的存放位置,然后直接获取即可.

1. 普通索引 只能帮助查找
    {% codeblock 创建表和索引%}
    create table in1(
        nid int not null auto_increment primary key,
        name varchar(32) not null,
        email varchar(64) not null,
        extra text,
        index ix_name (name)
    )
    {% endcodeblock %}

    {% codeblock 创建索引 %}
    create index index_name on table_name(column_name)
    {% endcodeblock %}

    {% codeblock 删除索引 %}
    drop index_name on table_name;
    {% endcodeblock %}

    {% codeblock 查看索引 %}
    show index from table_name;
    {% endcodeblock %}

    注意:对于创建索引时如果是blob和text类型,必须指定length.

    {% codeblock %}
    create index ix_extra on in1(extra(32));
    {% endcodeblock %}

2. 唯一索引 只能帮助查找,内容不允许重复(允许null)
    {% codeblock 创建表和唯一索引 %}
    create table in1(
        nid int not null auto_increment primary key,
        name varchar(32) not null,
        email varchar(64) not null,
        extra text,
        unique ix_name (name)
    )
    {% endcodeblock %}

    {% codeblock 创建唯一索引 %}
    create unique index 索引名 on 表名(列名)
    {% endcodeblock %}

    {% codeblock 删除唯一索引 %}
    drop unique index 索引名 on 表名
    {% endcodeblock %}

3. 主键索引 只能帮助查找,内容不允许重复,不允许null,一个表只能有一个主键
    {% codeblock 创建表和主键 %}
    create table in1(
        nid int not null auto_increment primary key,
        name varchar(32) not null,
        email varchar(64) not null,
        extra text,
        index ix_name (name)
    )

    OR

    create table in1(
        nid int not null auto_increment,
        name varchar(32) not null,
        email varchar(64) not null,
        extra text,
        primary key(ni1),
        index ix_name (name)
    )
    {% endcodeblock %}

    {% codeblock 创建主键 %}
    alter table 表名 add primary key(列名);
    {% endcodeblock %}

    {% codeblock 删除主键 %}
    alter table 表名 drop primary key;
    alter table 表名  modify  列名 int, drop primary key;
    {% endcodeblock %}

4. 组合索引 多列共同组成一个索引
    最左前缀 在单独查找除去左的一列的别的列是不会使用索引的.
    {% codeblock 创建组合索引 %}
    create index ix_name_email on in3(name,email);
    {% endcodeblock %}
5. 全文索引 对所有字段内容的索引,通过分词实现.

6. 正确使用索引
    {% codeblock 相关命令 %}
    - 查看表结构
            desc 表名
         
        - 查看生成表的SQL
            show create table 表名
         
        - 查看索引
            show index from  表名
         
        - 查看执行时间
            set profiling = 1;
            SQL...
            show profiles;
    {% endcodeblock %}
    {% codeblock 正确使用索引 %}
        - like '%xx'
        select * from tb1 where name like '%cn';
    - 使用函数
        select * from tb1 where reverse(name) = 'wupeiqi';
    - or
        select * from tb1 where nid = 1 or email = 'seven@live.com';
        特别的：当or条件中有未建立索引的列才失效，以下会走索引
                select * from tb1 where nid = 1 or name = 'seven';
                select * from tb1 where nid = 1 or email = 'seven@live.com' and name = 'alex'
    - 类型不一致
        如果列是字符串类型，传入条件是必须用引号引起来，不然...
        select * from tb1 where name = 999;
    - !=
        select * from tb1 where name != 'alex'
        特别的：如果是主键，则还是会走索引
            select * from tb1 where nid != 123
    - >
        select * from tb1 where name > 'alex'
        特别的：如果是主键或索引是整数类型，则还是会走索引
            select * from tb1 where nid > 123
            select * from tb1 where num > 123
    - order by
        select email from tb1 order by name desc;
        当根据索引排序时候，选择的映射如果不是索引，则不走索引
        特别的：如果对主键排序，则还是走索引：
            select * from tb1 order by nid desc;
     
    - 组合索引最左前缀
        如果组合索引为：(name,email)
        name and email       -- 使用索引
        name                 -- 使用索引
        email                -- 不使用索引
    {% endcodeblock %}

    {% codeblock 注意事项 %}
    - 避免使用select *
    - count(1)或count(列) 代替 count(*)
    - 创建表时尽量时 char 代替 varchar
    - 表的字段顺序固定长度的字段优先
    - 组合索引代替多个单列索引（经常使用多个条件查询时）
    - 尽量使用短索引
    - 使用连接（JOIN）来代替子查询(Sub-Queries)
    - 连表时注意条件类型需一致
    - 索引散列值（重复少）不适合建索引，例：性别不适合
    {% endcodeblock %}

#### 数据库分页
无论是否有索引，limit分页是一个值得关注的问题
{% codeblock %}
{% raw %}
每页显示10条：
当前 118 120， 125

倒序：
            大      小
            980    970  7 6  6 5  54  43  32

21 19 98     
下一页：

    select 
        * 
    from 
        tb1 
    where 
        nid < (select nid from (select nid from tb1 where nid < 当前页最小值 order by nid desc limit 每页数据 *【页码-当前页】) A order by A.nid asc limit 1)  
    order by 
        nid desc 
    limit 10;



    select 
        * 
    from 
        tb1 
    where 
        nid < (select nid from (select nid from tb1 where nid < 970  order by nid desc limit 40) A order by A.nid asc limit 1)  
    order by 
        nid desc 
    limit 10;


上一页：

    select 
        * 
    from 
        tb1 
    where 
        nid < (select nid from (select nid from tb1 where nid > 当前页最大值 order by nid asc limit 每页数据 *【当前页-页码】) A order by A.nid asc limit 1)  
    order by 
        nid desc 
    limit 10;


    select 
        * 
    from 
        tb1 
    where 
        nid < (select nid from (select nid from tb1 where nid > 980 order by nid asc limit 20) A order by A.nid desc limit 1)  
    order by 
        nid desc 
    limit 10;
{% endraw %}
{% endcodeblock %}

#### 计划执行
explain + 查询SQL - 用于显示SQL执行信息参数，根据参考信息可以进行SQL优化
{% codeblock %}
{% raw %}
mysql> explain select * from tb2;
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
|  1 | SIMPLE      | tb2   | ALL  | NULL          | NULL | NULL    | NULL |    2 | NULL  |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
1 row in set (0.00 sec)
{% endraw %}
{% endcodeblock %}


{% codeblock 详细 %}
{% raw %}
    id
        查询顺序标识
            如：mysql> explain select * from (select nid,name from tb1 where nid < 10) as B;
            +----+-------------+------------+-------+---------------+---------+---------+------+------+-------------+
            | id | select_type | table      | type  | possible_keys | key     | key_len | ref  | rows | Extra       |
            +----+-------------+------------+-------+---------------+---------+---------+------+------+-------------+
            |  1 | PRIMARY     | <derived2> | ALL   | NULL          | NULL    | NULL    | NULL |    9 | NULL        |
            |  2 | DERIVED     | tb1        | range | PRIMARY       | PRIMARY | 8       | NULL |    9 | Using where |
            +----+-------------+------------+-------+---------------+---------+---------+------+------+-------------+
        特别的：如果使用union连接气值可能为null


    select_type
        查询类型
            SIMPLE          简单查询
            PRIMARY         最外层查询
            SUBQUERY        映射为子查询
            DERIVED         子查询
            UNION           联合
            UNION RESULT    使用联合的结果
            ...
    table
        正在访问的表名


    type
        查询时的访问方式，性能：all < index < range < index_merge < ref_or_null < ref < eq_ref < system/const
            ALL             全表扫描，对于数据表从头到尾找一遍
                            select * from tb1;
                            特别的：如果有limit限制，则找到之后就不在继续向下扫描
                                   select * from tb1 where email = 'seven@live.com'
                                   select * from tb1 where email = 'seven@live.com' limit 1;
                                   虽然上述两个语句都会进行全表扫描，第二句使用了limit，则找到一个后就不再继续扫描。

            INDEX           全索引扫描，对索引从头到尾找一遍
                            select nid from tb1;

            RANGE          对索引列进行范围查找
                            select *  from tb1 where name < 'alex';
                            PS:
                                between and
                                in
                                >   >=  <   <=  操作
                                注意：!= 和 > 符号


            INDEX_MERGE     合并索引，使用多个单列索引搜索
                            select *  from tb1 where name = 'alex' or nid in (11,22,33);

            REF             根据索引查找一个或多个值
                            select *  from tb1 where name = 'seven';

            EQ_REF          连接时使用primary key 或 unique类型
                            select tb2.nid,tb1.name from tb2 left join tb1 on tb2.nid = tb1.nid;



            CONST           常量
                            表最多有一个匹配行,因为仅有一行,在这行的列值可被优化器剩余部分认为是常数,const表很快,因为它们只读取一次。
                            select nid from tb1 where nid = 2 ;

            SYSTEM          系统
                            表仅有一行(=系统表)。这是const联接类型的一个特例。
                            select * from (select nid from tb1 where nid = 1) as A;
    possible_keys
        可能使用的索引

    key
        真实使用的

    key_len
        MySQL中使用索引字节长度

    rows
        mysql估计为了找到所需的行而要读取的行数 ------ 只是预估值

    extra
        该列包含MySQL解决查询的详细信息
        “Using index”
            此值表示mysql将使用覆盖索引，以避免访问表。不要把覆盖索引和index访问类型弄混了。
        “Using where”
            这意味着mysql服务器将在存储引擎检索行后再进行过滤，许多where条件里涉及索引中的列，当（并且如果）它读取索引时，就能被存储引擎检验，因此不是所有带where子句的查询都会显示“Using where”。有时“Using where”的出现就是一个暗示：查询可受益于不同的索引。
        “Using temporary”
            这意味着mysql在对查询结果排序时会使用一个临时表。
        “Using filesort”
            这意味着mysql会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。mysql有两种文件排序算法，这两种排序方式都可以在内存或者磁盘上完成，explain不会告诉你mysql将使用哪一种文件排序，也不会告诉你排序会在内存里还是磁盘上完成。
        “Range checked for each record(index map: N)”
            这个意味着没有好用的索引，新的索引将在联接的每一行上重新估算，N是显示在possible_keys列中索引的位图，并且是冗余的。
{% endraw %}
{% endcodeblock %}

#### 慢日志查询
配置MySQL自动记录慢日志

{% codeblock %}
slow_query_log = OFF                            是否开启慢日志记录
long_query_time = 2                              时间限制，超过此时间，则记录
slow_query_log_file = /usr/slow.log        日志文件
log_queries_not_using_indexes = OFF     为使用索引的搜索是否记录

注：查看当前配置信息：
　　     show variables like '%query%'
     修改当前配置：
　　　　set global 变量名 = 值
{% endcodeblock %}

查看MySQL慢日志

{% codeblock %}
{% raw %}
mysqldumpslow -s at -a  /usr/local/var/mysql/MacBook-Pro-3-slow.log
"""
--verbose    版本
--debug      调试
--help       帮助
 
-v           版本
-d           调试模式
-s ORDER     排序方式
             what to sort by (al, at, ar, c, l, r, t), 'at' is default
              al: average lock time
              ar: average rows sent
              at: average query time
               c: count
               l: lock time
               r: rows sent
               t: query time
-r           反转顺序，默认文件倒序拍。reverse the sort order (largest last instead of first)
-t NUM       显示前N条just show the top n queries
-a           不要将SQL中数字转换成N，字符串转换成S。don't abstract all numbers to N and strings to 'S'
-n NUM       abstract numbers with at least n digits within names
-g PATTERN   正则匹配；grep: only consider stmts that include this string
-h HOSTNAME  mysql机器名或者IP；hostname of db server for *-slow.log filename (can be wildcard),
             default is '*', i.e. match all
-i NAME      name of server instance (if using mysql.server startup script)
-l           总时间中不减去锁定时间；don't subtract lock time from total time
"""
{% endraw %}
{% endcodeblock %}

------

### Python操作Mysql

#### 用pymysql模块操作
pymsql是Python中操作MySQL的模块，其使用方法和MySQLdb几乎相同.

1. 安装
    {% codeblock %}    
    pip3 install pymysql
    {% endcodeblock %}

2. 执行sql
    {% codeblock %}    
    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import pymysql
      
    # 创建连接
    conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='123', db='t1')
    # 创建游标
    cursor = conn.cursor()
      
    # 执行SQL，并返回收影响行数
    effect_row = cursor.execute("update hosts set host = '1.1.1.2'")
      
    # 执行SQL，并返回受影响行数
    #effect_row = cursor.execute("update hosts set host = '1.1.1.2' where nid > %s", (1,))
      
    # 执行SQL，并返回受影响行数
    #effect_row = cursor.executemany("insert into hosts(host,color_id)values(%s,%s)", [("1.1.1.11",1),("1.1.1.11",2)])
      
      
    # 提交，不然无法保存新建或者修改的数据
    conn.commit()
      
    # 关闭游标
    cursor.close()
    # 关闭连接
    conn.close()
    {% endcodeblock %}

3. 获取新插入数据的自增ID
    {% codeblock %}
    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import pymysql
      
    conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='123', db='t1')
    cursor = conn.cursor()
    cursor.executemany("insert into hosts(host,color_id)values(%s,%s)", [("1.1.1.11",1),("1.1.1.11",2)])
    conn.commit()
    cursor.close()
    conn.close()
      
    # 获取最新自增ID
    new_id = cursor.lastrowid
    {% endcodeblock %}

4. 获取查询数据
    {% codeblock %}
    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import pymysql
      
    conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='123', db='t1')
    cursor = conn.cursor()
    cursor.execute("select * from hosts")
      
    # 获取第一行数据
    row_1 = cursor.fetchone()
      
    # 获取前n行数据
    # row_2 = cursor.fetchmany(3)
    # 获取所有数据
    # row_3 = cursor.fetchall()
    cursor.scroll(1,mode='relative')  # 相对当前位置移动
    cursor.scroll(2,mode='absolute') # 相对绝对位置移动
    conn.commit()
    cursor.close()
    conn.close()
    {% endcodeblock %}

5. fetch数据类型
    默认获取的数据类型是元组,如果想获取字典(也就是包含了列名)
    {% codeblock %}
    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import pymysql
      
    conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='123', db='t1')
      
    # 游标设置为字典类型
    cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)
    r = cursor.execute("call p1()")
      
    result = cursor.fetchone()
      
    conn.commit()
    cursor.close()
    conn.close()
    {% endcodeblock %}

#### SQLAchemy操作数据库
SQLAlchemy是Python编程语言下的一款ORM框架,该框架建立在数据库API之上,使用关系对象映射进行数据库操作,简言之便是:将对象转换成SQL,然后使用数据API执行SQL并获取执行结果.


安装
{% codeblock %}
pip3 install SQLAlchemy
{% endcodeblock %}

SQLAlchemy本身无法操作数据库,其必须以来pymsql等第三方插件,Dialect用于和数据API进行交流,根据配置文件的不同调用不同的数据库API,从而实现对数据库的操作,如:

{% codeblock %}
MySQL-Python
    mysql+mysqldb://<user>:<password>@<host>[:<port>]/<dbname>
   
pymysql
    mysql+pymysql://<username>:<password>@<host>/<dbname>[?<options>]
   
MySQL-Connector
    mysql+mysqlconnector://<user>:<password>@<host>[:<port>]/<dbname>
   
cx_Oracle
    oracle+cx_oracle://user:pass@host:port/dbname[?key=value&key=value...]
   
更多详见:http://docs.sqlalchemy.org/en/latest/dialects/index.html
{% endcodeblock %}

1. 内部处理
    使用,Engine/ConnectionPooling/Dialect,进行数据库操作,Engine使用ConnectionPooling连接数据库,然后再通过Dialect执行SQL语句.
    {% codeblock %}
    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    from sqlalchemy import create_engine
      
      
    engine = create_engine("mysql+pymysql://root:123@127.0.0.1:3306/t1", max_overflow=5)
      
    # 执行SQL
    # cur = engine.execute(
    #     "INSERT INTO hosts (host, color_id) VALUES ('1.1.1.22', 3)"
    # )
      
    # 新插入行自增ID
    # cur.lastrowid
      
    # 执行SQL
    # cur = engine.execute(
    #     "INSERT INTO hosts (host, color_id) VALUES(%s, %s)",[('1.1.1.22', 3),('1.1.1.221', 3),]
    # )
      
      
    # 执行SQL
    # cur = engine.execute(
    #     "INSERT INTO hosts (host, color_id) VALUES (%(host)s, %(color_id)s)",
    #     host='1.1.1.99', color_id=3
    # )
      
    # 执行SQL
    # cur = engine.execute('select * from hosts')
    # 获取第一行数据
    # cur.fetchone()
    # 获取第n行数据
    # cur.fetchmany(3)
    # 获取所有数据
    # cur.fetchall()
    {% endcodeblock %}

2. ORM功能使用
    使用ORM/Schema,Type/SQL,Expression,Language/Engine/ConnectionPooling/Dialect,所有组件对数据进行操作.根据类创建对象,对象转换成SQL,执行SQL.
    {% codeblock 创建表 %}
    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    from sqlalchemy.ext.declarative import declarative_base
    from sqlalchemy import Column, Integer, String, ForeignKey, UniqueConstraint, Index
    from sqlalchemy.orm import sessionmaker, relationship
    from sqlalchemy import create_engine
     
    engine = create_engine("mysql+pymysql://root:123@127.0.0.1:3306/t1", max_overflow=5)
     
    Base = declarative_base()
     
    # 创建单表
    class Users(Base):
        __tablename__ = 'users'
        id = Column(Integer, primary_key=True)
        name = Column(String(32))
        extra = Column(String(16))
     
        __table_args__ = (
        UniqueConstraint('id', 'name', name='uix_id_name'),
            Index('ix_id_name', 'name', 'extra'),
        )
     
     
    # 一对多
    class Favor(Base):
        __tablename__ = 'favor'
        nid = Column(Integer, primary_key=True)
        caption = Column(String(50), default='red', unique=True)
     
     
    class Person(Base):
        __tablename__ = 'person'
        nid = Column(Integer, primary_key=True)
        name = Column(String(32), index=True, nullable=True)
        favor_id = Column(Integer, ForeignKey("favor.nid"))
     
     
    # 多对多
    class Group(Base):
        __tablename__ = 'group'
        id = Column(Integer, primary_key=True)
        name = Column(String(64), unique=True, nullable=False)
        port = Column(Integer, default=22)
     
     
    class Server(Base):
        __tablename__ = 'server'
     
        id = Column(Integer, primary_key=True, autoincrement=True)
        hostname = Column(String(64), unique=True, nullable=False)
     
     
    class ServerToGroup(Base):
        __tablename__ = 'servertogroup'
        nid = Column(Integer, primary_key=True, autoincrement=True)
        server_id = Column(Integer, ForeignKey('server.id'))
        group_id = Column(Integer, ForeignKey('group.id'))
     
     
    def init_db():
        Base.metadata.create_all(engine)
     
     
    def drop_db():
        Base.metadata.drop_all(engine)
    {% endcodeblock %}
    注:设置外检的另一种方式,`ForeignKeyConstraint(['other_id'], ['othertable.other_id'])`

    {% codeblock 表结构和数据库连接 %}
    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    from sqlalchemy.ext.declarative import declarative_base
    from sqlalchemy import Column, Integer, String, ForeignKey, UniqueConstraint, Index
    from sqlalchemy.orm import sessionmaker, relationship
    from sqlalchemy import create_engine

    engine = create_engine("mysql+pymysql://root:123@127.0.0.1:3306/t1", max_overflow=5)

    Base = declarative_base()

    # 创建单表
    class Users(Base):
        __tablename__ = 'users'
        id = Column(Integer, primary_key=True)
        name = Column(String(32))
        extra = Column(String(16))

        __table_args__ = (
        UniqueConstraint('id', 'name', name='uix_id_name'),
            Index('ix_id_name', 'name', 'extra'),
        )

        def __repr__(self):
            return "%s-%s" %(self.id, self.name)

    # 一对多
    class Favor(Base):
        __tablename__ = 'favor'
        nid = Column(Integer, primary_key=True)
        caption = Column(String(50), default='red', unique=True)

        def __repr__(self):
            return "%s-%s" %(self.nid, self.caption)

    class Person(Base):
        __tablename__ = 'person'
        nid = Column(Integer, primary_key=True)
        name = Column(String(32), index=True, nullable=True)
        favor_id = Column(Integer, ForeignKey("favor.nid"))
        # 与生成表结构无关，仅用于查询方便
        favor = relationship("Favor", backref='pers')

    # 多对多
    class ServerToGroup(Base):
        __tablename__ = 'servertogroup'
        nid = Column(Integer, primary_key=True, autoincrement=True)
        server_id = Column(Integer, ForeignKey('server.id'))
        group_id = Column(Integer, ForeignKey('group.id'))
        group = relationship("Group", backref='s2g')
        server = relationship("Server", backref='s2g')

    class Group(Base):
        __tablename__ = 'group'
        id = Column(Integer, primary_key=True)
        name = Column(String(64), unique=True, nullable=False)
        port = Column(Integer, default=22)
        # group = relationship('Group',secondary=ServerToGroup,backref='host_list')


    class Server(Base):
        __tablename__ = 'server'

        id = Column(Integer, primary_key=True, autoincrement=True)
        hostname = Column(String(64), unique=True, nullable=False)




    def init_db():
        Base.metadata.create_all(engine)


    def drop_db():
        Base.metadata.drop_all(engine)


    Session = sessionmaker(bind=engine)
    session = Session()
    {% endcodeblock %}

    {% codeblock 增 %}
    obj = Users(name="alex0", extra='sb')
    session.add(obj)
    session.add_all([
        Users(name="alex1", extra='sb'),
        Users(name="alex2", extra='sb'),
    ])
    session.commit()
    {% endcodeblock %}

    {% codeblock 删 %}
    session.query(Users).filter(Users.id > 2).delete()
    session.commit()
    {% endcodeblock %}

    {% codeblock 改 %}
    session.query(Users).filter(Users.id > 2).update({"name" : "099"})
    session.query(Users).filter(Users.id > 2).update({Users.name: Users.name + "099"}, synchronize_session=False)
    session.query(Users).filter(Users.id > 2).update({"num": Users.num + 1}, synchronize_session="evaluate")
    session.commit()
    {% endcodeblock %}

    {% codeblock 查 %}
    ret = session.query(Users).all()
    ret = session.query(Users.name, Users.extra).all()
    ret = session.query(Users).filter_by(name='alex').all()
    ret = session.query(Users).filter_by(name='alex').first()

    ret = session.query(Users).filter(text("id<:value and name=:name")).params(value=224, name='fred').order_by(User.id).all()

    ret = session.query(Users).from_statement(text("SELECT * FROM users where name=:name")).params(name='ed').all()
    {% endcodeblock %}

    {% codeblock 其他 %}
    #　条件
    ret = session.query(Users).filter_by(name='alex').all()
    ret = session.query(Users).filter(Users.id > 1, Users.name == 'eric').all()
    ret = session.query(Users).filter(Users.id.between(1, 3), Users.name == 'eric').all()
    ret = session.query(Users).filter(Users.id.in_([1,3,4])).all()
    ret = session.query(Users).filter(~Users.id.in_([1,3,4])).all()
    ret = session.query(Users).filter(Users.id.in_(session.query(Users.id).filter_by(name='eric'))).all()
    from sqlalchemy import and_, or_
    ret = session.query(Users).filter(and_(Users.id > 3, Users.name == 'eric')).all()
    ret = session.query(Users).filter(or_(Users.id < 2, Users.name == 'eric')).all()
    ret = session.query(Users).filter(
        or_(
            Users.id < 2,
            and_(Users.name == 'eric', Users.id > 3),
            Users.extra != ""
        )).all()


    # 通配符
    ret = session.query(Users).filter(Users.name.like('e%')).all()
    ret = session.query(Users).filter(~Users.name.like('e%')).all()

    # 限制
    ret = session.query(Users)[1:2]

    # 排序
    ret = session.query(Users).order_by(Users.name.desc()).all()
    ret = session.query(Users).order_by(Users.name.desc(), Users.id.asc()).all()

    # 分组
    from sqlalchemy.sql import func

    ret = session.query(Users).group_by(Users.extra).all()
    ret = session.query(
        func.max(Users.id),
        func.sum(Users.id),
        func.min(Users.id)).group_by(Users.name).all()

    ret = session.query(
        func.max(Users.id),
        func.sum(Users.id),
        func.min(Users.id)).group_by(Users.name).having(func.min(Users.id) >2).all()

    # 连表

    ret = session.query(Users, Favor).filter(Users.id == Favor.nid).all()

    ret = session.query(Person).join(Favor).all()

    ret = session.query(Person).join(Favor, isouter=True).all()


    # 组合
    q1 = session.query(Users.name).filter(Users.id > 2)
    q2 = session.query(Favor.caption).filter(Favor.nid < 2)
    ret = q1.union(q2).all()

    q1 = session.query(Users.name).filter(Users.id > 2)
    q2 = session.query(Favor.caption).filter(Favor.nid < 2)
    ret = q1.union_all(q2).all()
    {% endcodeblock %}